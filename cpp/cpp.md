# 简介
c/c++ 的基础知识

## memcpy
memcpy 是 c/c++ 中常用的内存拷贝函数。它将 src 内存内的值拷贝到 dest 中。最简单的实现方式是一个字节一个字节的拷贝，但是这种方式性能较低。另外还需要处理内存重叠的问题。
拷贝性能: 对于 32 位的机器，地址总线是 32 位，一次可以复制 4 字节，效率更高。
内存重叠: 如果 dest 和 src 的内存存在重叠情况，需要处理。若是 dest 起始部分与 src 存在重叠，则需要从末端开始拷贝，以避免覆盖情况。

## 对象生存周期和资源管理(RALL, Resource Acquisition is Initialization) 
C++ 没有自动垃圾回收。RALL 资源获取即初始化，它的核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RALL 指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的层次。
现代 C++ 通过声明堆栈上的对象尽可能避免使用堆内存。对于需要较大资源的堆栈，它应尽可能归对象所有。对象初始化时，获取它拥有的资源，最后在析构函数中释放资源。
在 C++ 11 中，标准库提供了智能指针。智能指针处理拥有的内存的分配和删除，无需显示的编写析构函数。


## 常见题目
1. 类的缺省函数？
-   构造函数、析构函数、拷贝构造函数、赋值函数
2. 拷贝构造函数被调用？
- 类对象初始化另一个对象、函数的形参是类对象、函数的返回值是类的对象。
3. 什么时候重写拷贝构造函数？
- 涉及到动态存储分配空间的时候，要自己写拷贝构造函数，且需要深拷贝。
4. 友元、继承、公有成员函数等的作用？
- 友元可以用于在类外访问类的非公有成员。
5. 对象间如何实现数据的共享？
- 通过类的静态成员变量实现对象的数据共享。
6. 虚函数如何实现的？
- 虚函数表
7. delete 与 delete[] 的区别？
- delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。
8. 堆和栈的区别？
- 栈区市由编译器自动分配释放，存放函数的参考值，局部变量等信息。堆区则一般是由程序员分配释放，或在程序结束时由操作系统回收，也可能造成内存泄漏。
9. 虚拟函数与普通成员函数的区别？内联函数和构造函数能否为虚拟函数？
- 虚拟函数是 virtual 关键字区分，有虚拟指针和虚函数表，普通成员函数没有。内联函数和构造函数不能为虚拟函数。