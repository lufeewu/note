# 简介
c/c++ 的基础知识

## memcpy
memcpy 是 c/c++ 中常用的内存拷贝函数。它将 src 内存内的值拷贝到 dest 中。最简单的实现方式是一个字节一个字节的拷贝，但是这种方式性能较低。另外还需要处理内存重叠的问题。
拷贝性能: 对于 32 位的机器，地址总线是 32 位，一次可以复制 4 字节，效率更高。
内存重叠: 如果 dest 和 src 的内存存在重叠情况，需要处理。若是 dest 起始部分与 src 存在重叠，则需要从末端开始拷贝，以避免覆盖情况。

## 对象生存周期和资源管理(RALL, Resource Acquisition is Initialization) 
C++ 没有自动垃圾回收。RALL 资源获取即初始化，它的核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RALL 指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的层次。
现代 C++ 通过声明堆栈上的对象尽可能避免使用堆内存。对于需要较大资源的堆栈，它应尽可能归对象所有。对象初始化时，获取它拥有的资源，最后在析构函数中释放资源。
在 C++ 11 中，标准库提供了智能指针。智能指针处理拥有的内存的分配和删除，无需显示的编写析构函数。


## 文件
在 cpp 工程中，包含两类文件，.cpp 文件和 .h 文件，其中 .cpp 文件被称作 c++ 源文件，里面主要放 c++ 的源代码，而 .h 文件则被称作 c++ 头文件。
## 源文件 .cpp

## 头文件 .h 
cpp 的头文件 .h 的作用主要是被其它的 .cpp 文件包含进去，在 cpp 文件中，可以通过 #include 来关联头文件。本身不参与编译，但是实际上它们的内容在多个 .cpp 文件中得到了编译。头文件中应该只放变量和函数的声明，而不能放他们的定义。但有三个例外:
1. 头文件中可以写 const 对象的定义。
2. 头文件中可以写内联函数(inline)的定义。
3. 头文件中可以写类(class)的定义。

在编译的时候，并不会去寻找 .h 文件的实现，而是在 link 的时候去寻找。在 cpp 文件中引入 #include 实际上只是引入申明，使得编译可以通过。程序并不关心实现在哪里。源文件编译后生成目标文件(.o 或 .obj 文件)，在目标文件中，函数和变量作为一个符号。在 Makefile 中需要说明链接哪个 .o 或 .obj 文件，此时连接器会去这个 .o 或 .obj 文件中找到 cpp 文件中实现的函数，再把它们 build 到 Makefile 指定的可执行文件中。

.h 文件中能包含的内容:
1. 类成员数据的声明，但不能赋值。
2. 类静态数据成员的定义和赋值，但不建议，只声明即可。
3. 类的成员函数声明
4. 非类的成员函数的声明
5. 常熟的定义: 如 constint a = 5
6. 静态函数的定义
7. 类的内联函数的定义

.h 文件中不能包含的内容: 
1. 所有非静态变量(不是类的数据成员) 的声明
2. 默认命名空间的声明不放在头文件，using namespace std; 应放在 .cpp 文件中, 在 .h 文件中可以使用 std::string 等。

## 多文件编译
cpp 的多文件编译方式主要是借助编译、链接过程

## 常见题目
1. 类的缺省函数？
-   构造函数、析构函数、拷贝构造函数、赋值函数
2. 拷贝构造函数被调用？
- 类对象初始化另一个对象、函数的形参是类对象、函数的返回值是类的对象。
3. 什么时候重写拷贝构造函数？
- 涉及到动态存储分配空间的时候，要自己写拷贝构造函数，且需要深拷贝。
4. 友元、继承、公有成员函数等的作用？
- 友元可以用于在类外访问类的非公有成员。
5. 对象间如何实现数据的共享？
- 通过类的静态成员变量实现对象的数据共享。
6. 虚函数如何实现的？
- 虚函数表
7. delete 与 delete[] 的区别？
- delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。
8. 堆和栈的区别？
- 栈区市由编译器自动分配释放，存放函数的参考值，局部变量等信息。堆区则一般是由程序员分配释放，或在程序结束时由操作系统回收，也可能造成内存泄漏。
9. 虚拟函数与普通成员函数的区别？内联函数和构造函数能否为虚拟函数？
- 虚拟函数是 virtual 关键字区分，有虚拟指针和虚函数表，普通成员函数没有。内联函数和构造函数不能为虚拟函数。

## 语法
c++ 的一些语法。

### switch case 语法
switch case, 一个 switch 语句可以测试一个变量等于多个值的情况，每个值为一个 case。使用示例如下:

        switch(expression){
            case constant-expression:
                statement(s);
                break; // 可选的
            case constant-expression:
                statement(s);
                break; // 可选的
            default : // 可选的
                statement(s);
        }

switch 语句有以下规则需要遵循:
- switch 语句中的每个 expression 必须是一个整型或枚举型，或者是一个包含转换函数可转换为整型或枚举类型的 class 类型，expression 不能是 string 等类型，但可以是 char 等。
- 可以有任意数量的 case 语句。每个 case 语句后有一个比较值和一个冒号。
- case 的 constant-expression 与 expression 变量必须是相同数据类型，且必须是常量或字面量。
- 执行变量为等于 case 的变量，case 后的语句会被执行，直到遇到 break 语句。如果 case 语句没有 break，则会继续执行后面的 case。
- 当遇到 break 语句时，switch 终止。
- switch 可以包含一个 default 语句，在所有 case 不为真时执行 default 语句。

### 引用传值语法
c++ 可以通过 & 声明引用类型，在赋值后相当于给变量取别名。

### const 用法
const 是 constant 的缩写，在 c++ 中用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。const 用于告诉编译器某值是保持不变的，编译器会强制使用这个约束。

const 普通变量: 被定义为常量的变量，不能被再次赋值。
const 指针变量: const 修饰指针变量有三种情况，1. 修饰指针指向的内容，则内容为不可斌量。 2. 修饰指针，则指针不可变。 3. 修饰指针及指针指向的内容，则都不可变。

    const int *p = 8; // 修饰指向的内容
    int* const p1 = &a; // 修饰指针
    const int* const p2 = &a; // 修饰指针及指向的内容

const 参数传递和函数返回值: 
+ 修饰参数传递有三种情况, 1. 修饰值传递 2. 修饰指针 3. const & 传参
+ 修饰函数有三种情况, 1. 修饰内置类型返回值 2. 修饰自定义类型的作为返回值(不能被修改和被赋值) 3. 修饰返回的指针或引用

const 修饰成员函数: 可以防止成员函数修改被调用对象的值。


### 指针
dangling pointer: 当对象从内存中取消分配，但没有修改指向对象的指针的值，则出现 dangling pointer。
野指针: 指向内存被释放的内存或者没有访问权限的内存的指针。
悬空指针: 指向已经被删除对象的指针称为悬空指针。
智能指针: 指向动态分配(堆)对象指针的类。


### 命名空间 namespace
cpp 的命名空间定义可以使用关键字 namespace，后面跟命名空间的名称。 如: 

    // 定义
    namespace namespace_name {
        // 代码声明
    }
    // 使用
    name::code // 变量或函数

using 指令: 可以通过使用 using namespace 指令，这样使用命名空间时就可以不用在前面加上命名空间的名称。
不连续的命名空间: 一个命名空间的代码可以定义在不同的部分中，可以分散在多个文件中。
嵌套命名空间: 命名空间可以嵌套，可以在一个命名空间中定义另一个命名空间。在使用是通过 :: 嵌套访问。